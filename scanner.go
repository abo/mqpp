package mqpp

import (
	"bufio"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
)

// MQTT Protocol Name and Level
const (
	ProtocolName  = "MQTT"
	ProtocolLevel = 4
)

// MQTT Control Packet types
const (
	RESERVED byte = iota
	CONNECT
	CONNACK
	PUBLISH
	PUBACK
	PUBREC
	PUBREL
	PUBCOMP
	SUBSCRIBE
	SUBACK
	UNSUBSCRIBE
	UNSUBACK
	PINGREQ
	PINGRESP
	DISCONNECT
)

// QoS definitions
const (
	QosAtMostOnce byte = iota
	QosAtLeastOnce
	QosExactlyOnce
)

// Connect Return Code
const (
	Accepted byte = iota
	RefusedProtocolVersion
	RefusedInvalidIdentifier
	RefusedServerUnavailable
	RefusedBadCredentials
	RefusedUnauthorized
)

// ConnectReturnCodeResponses - Connect Return code descriptions
var ConnectReturnCodeResponses = map[byte]string{
	Accepted:                 fmt.Sprintf("%#02x Connection Accepted", Accepted),
	RefusedProtocolVersion:   fmt.Sprintf("%#02x Connection Refused, unacceptable protocol version", RefusedProtocolVersion),
	RefusedInvalidIdentifier: fmt.Sprintf("%#02x Connection Refused, identifier rejected", RefusedInvalidIdentifier),
	RefusedServerUnavailable: fmt.Sprintf("%#02x Connection Refused, server unavailable", RefusedServerUnavailable),
	RefusedBadCredentials:    fmt.Sprintf("%#02x Connection Refused, bad user name or password", RefusedBadCredentials),
	RefusedUnauthorized:      fmt.Sprintf("%#02x Connection Refused, not authorized", RefusedUnauthorized),
}

// ControlPacket is interface of basic MQTT packet
type ControlPacket interface {
	Type() byte
	Length() uint32
	io.WriterTo
}

// packetBytes is a byte array which is a mqtt packet
type packetBytes []byte

// Length return how many bytes this packet
func (pbs packetBytes) Length() uint32 {
	return uint32(len(pbs))
}

// Type return packet type
func (pbs packetBytes) Type() byte {
	return pbs[0] >> 4
}

// WriteTo write packet to w
func (pbs packetBytes) WriteTo(w io.Writer) (int64, error) {
	n, err := w.Write(pbs)
	return int64(n), err
}

var (
	// ErrMalformedRemLen - can not decoding packet's remaining length, or remaining
	// length larger than 268,435,455(max length according MQTT specification)
	ErrMalformedRemLen = errors.New("mqpp: Malformed Remaining Length")
	// ErrIncompletePacket - there are no more data for remaining length
	ErrIncompletePacket = errors.New("mqpp: Incomplete Packet")
	// ErrProtocolViolation - protocol violation according MQTT specification
	ErrProtocolViolation = errors.New("mqpp: Protocol Violation")
)

// Scanner wrap bufio.Scanner with SplitFunc which scanning a file into mqtt packets
type Scanner struct {
	bufio.Scanner
}

// Packet returns the most recent token generated by a call to Scan as a mqtt packet holding its bytes.
func (s *Scanner) Packet() (ControlPacket, error) {
	data := s.Bytes()
	switch data[0] >> 4 {
	case CONNECT:
		return newConnect(data)
	case CONNACK:
		return newConnack(data)
	case PUBLISH:
		return newPublish(data)
	case PUBACK:
		return newPuback(data)
	case PUBREC:
		return newPubrec(data)
	case PUBREL:
		return newPubrel(data)
	case PUBCOMP:
		return newPubcomp(data)
	case SUBSCRIBE:
		return newSubscribe(data)
	case SUBACK:
		return newSuback(data)
	case UNSUBSCRIBE:
		return newUnsubscribe(data)
	case UNSUBACK:
		return newUnsuback(data)
	case PINGREQ:
		return newPingreq(data)
	case PINGRESP:
		return newPingresp(data)
	case DISCONNECT:
		return newDisconnect(data)
	default:
		return nil, errors.New("Reserved Packet Type")
	}
}

// NewScanner returns a new Scanner to read from r, with The split function splitPackets.
func NewScanner(r io.Reader) *Scanner {
	splitter := bufio.NewScanner(r)
	splitter.Split(splitPackets)
	return &Scanner{
		Scanner: *splitter,
	}
}

// splitPackets is a split function for a bufio.Scanner that returns each
// MQTT packet as a token. it just cut by length, the token maybe protocol
// violation, so check it yourself
func splitPackets(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if len(data) == 0 {
		return 0, nil, nil
	}

	l, n := decRemLen(data[1:])

	if n == 0 {
		if atEOF {
			return 1, nil, ErrIncompletePacket
		}

		return 0, nil, nil
	}

	if n < 0 {
		return n, nil, ErrMalformedRemLen
	}

	packetLen := int(l) + n + 1
	if len(data) >= packetLen {
		return packetLen, data[0:packetLen], nil
	} else if atEOF {
		return len(data), nil, ErrIncompletePacket
	} else {
		return 0, nil, nil
	}
}

// is bit position set or not
func bit(b byte, n uint8) bool {
	return b&(1<<n) != 0
}

func set(n uint8, v bool) byte {
	if v {
		return byte(1) << n
	}
	return byte(0)
}

// fill byte array, return how many bytes writen
// if n < 0, meanings unsupport type, -n bytes writen
func fill(bs []byte, vals ...interface{}) int {
	offset := 0
	for _, val := range vals {
		switch val.(type) {
		case byte:
			bs[offset] = val.(byte)
			offset++
		case uint16:
			binary.BigEndian.PutUint16(bs[offset:], val.(uint16))
			offset += 2
		case uint32: // remaingLength
			n := binary.PutUvarint(bs[offset:], uint64(val.(uint32)))
			offset += n
		case string:
			str := val.(string)
			binary.BigEndian.PutUint16(bs[offset:], uint16(len(str)))
			offset += 2
			offset += copy(bs[offset:], str)
		case []byte:
			offset += copy(bs[offset:], val.([]byte))
		default: // unknown type
			return -offset
		}
	}
	return offset
}

// decode remaining length, and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 meaning:
//
//	n == 0: buf too small
//	n  < 0: value larger than 268,435,455 (overflow)
//              and -n is the number of bytes read
//
func decRemLen(data []byte) (uint32, int) {
	val, n := binary.Uvarint(data)
	if n > 0 && val > 268435455 {
		return 0, -n
	}

	return uint32(val), n
}

// how many bytes for encoding remlen
func lenRemLen(remlen uint32) int {
	if remlen <= 127 {
		return 1
	} else if remlen <= 16383 {
		return 2
	} else if remlen <= 2097151 {
		return 3
	} else if remlen <= 268435455 {
		return 4
	}
	return 0
}
